<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>深度对话卡牌游戏</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --primary: #5C6BC0;
      --primary-light: #7986CB;
      --accent: #FF7043;
      --bg: #F5F5F5;
      --card-bg: #fff;
      --text: #333;
      --text-light: #666;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: var(--text);
      overflow: hidden;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }
    
    /* 页面系统 - 点击跳转模式 */
    .page {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      padding: 20px;
      overflow-y: auto;
      transition: opacity 0.3s ease, transform 0.3s ease;
      opacity: 0;
      transform: translateX(100%);
    }
    
    .page.active {
      display: flex;
      opacity: 1;
      transform: translateX(0);
    }
    
    .page.exit {
      transform: translateX(-100%);
      opacity: 0;
    }
    
    /* ========== 通用组件 ========== */
    .page-header {
      text-align: center;
      padding: 40px 20px 30px;
    }
    
    .page-title {
      font-size: 28px;
      font-weight: 700;
      color: #fff;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
      margin-bottom: 8px;
    }
    
    .page-subtitle {
      font-size: 15px;
      color: rgba(255,255,255,0.85);
    }
    
    .content-card {
      background: #fff;
      border-radius: 24px;
      padding: 28px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      flex: 1;
      display: flex;
      flex-direction: column;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }
    
    .btn {
      width: 100%;
      padding: 16px;
      border: none;
      border-radius: 14px;
      font-size: 17px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s, box-shadow 0.2s;
    }
    
    .btn:active { transform: scale(0.98); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: #fff;
    }
    
    .btn-primary:hover:not(:disabled) {
      box-shadow: 0 6px 20px rgba(92, 107, 192, 0.4);
    }
    
    .btn-accent {
      background: linear-gradient(135deg, var(--accent), #FF8A65);
      color: #fff;
    }
    
    .btn-secondary {
      background: #f0f0f0;
      color: var(--text);
    }
    
    .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: auto;
      padding-top: 20px;
    }
    
    .btn-group .btn { flex: 1; min-width: 120px; }
    
    /* ========== 设置页 ========== */
    .setup-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      text-align: center;
      color: var(--primary);
    }
    
    .player-count-section {
      margin-bottom: 24px;
    }
    
    .section-label {
      font-size: 14px;
      color: var(--text-light);
      margin-bottom: 10px;
      display: block;
    }
    
    .count-options {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    
    .count-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 2px solid #eee;
      background: #fff;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .count-btn:hover { border-color: var(--primary-light); }
    .count-btn.active {
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    
    .player-inputs {
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 20px;
    }
    
    .player-input {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .player-avatar {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }
    
    .player-input input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #eee;
      border-radius: 12px;
      font-size: 15px;
      transition: border-color 0.2s;
    }
    
    .player-input input:focus {
      outline: none;
      border-color: var(--primary);
    }
    
    /* ========== 入游须知页 ========== */
    .rule-item {
      display: flex;
      gap: 16px;
      padding: 18px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .rule-item:last-of-type { border-bottom: none; }
    
    .rule-icon { font-size: 30px; flex-shrink: 0; }
    
    .rule-content h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--primary);
    }
    
    .rule-content p {
      font-size: 13px;
      color: var(--text-light);
      line-height: 1.5;
    }
    
    .confirm-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px dashed #eee;
    }
    
    .confirm-hint {
      text-align: center;
      font-size: 13px;
      color: var(--text-light);
      margin-bottom: 14px;
    }
    
    .confirm-avatars {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 18px;
    }
    
    .confirm-avatar {
      width: 54px;
      height: 54px;
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      border: 3px solid #eee;
      position: relative;
    }
    
    .confirm-avatar:hover { transform: scale(1.05); }
    
    .confirm-avatar.confirmed {
      border-color: #4CAF50;
      background: #E8F5E9;
    }
    
    .confirm-avatar.confirmed::after {
      content: '\2713';
      position: absolute;
      bottom: -4px;
      right: -4px;
      width: 18px;
      height: 18px;
      background: #4CAF50;
      color: #fff;
      border-radius: 50%;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .confirm-avatar-emoji { font-size: 22px; }
    .confirm-avatar-name {
      font-size: 9px;
      color: var(--text-light);
      margin-top: 2px;
      max-width: 48px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* ========== 功能牌选择页 ========== */
    .selector-info {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-bottom: 16px;
      margin-bottom: 16px;
      border-bottom: 1px solid #f0f0f0;
    }
    
    .selector-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    
    .selector-name { flex: 1; font-size: 17px; font-weight: 600; }
    .selector-progress { font-size: 13px; color: var(--primary); font-weight: 600; }
    
    .function-cards-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .func-card {
      border: 2px solid #eee;
      border-radius: 14px;
      padding: 14px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    
    .func-card:hover {
      border-color: var(--primary-light);
      background: #f8f9ff;
    }
    
    .func-card.selected {
      border-color: var(--primary);
      background: linear-gradient(135deg, #EDE7F6, #E8EAF6);
    }
    
    .func-card.disabled { opacity: 0.4; cursor: not-allowed; }
    
    .func-card-icon { font-size: 28px; margin-bottom: 6px; }
    .func-card-name { font-size: 13px; font-weight: 600; margin-bottom: 3px; }
    .func-card-desc { font-size: 10px; color: var(--text-light); line-height: 1.3; }
    
    /* ========== 游戏主页 ========== */
    .game-header {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 14px 18px;
      margin-bottom: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .current-player {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .current-avatar {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
    }
    
    .current-info h3 { font-size: 16px; font-weight: 600; }
    .current-info p { font-size: 12px; color: var(--text-light); }
    
    .round-info { text-align: right; }
    .round-number { font-size: 22px; font-weight: 700; color: var(--primary); }
    .round-label { font-size: 11px; color: var(--text-light); }
    
    /* 手牌区域 */
    .hand-section { margin-bottom: 16px; }
    
    .section-title {
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .hand-cards {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding: 8px 0;
      -webkit-overflow-scrolling: touch;
    }
    
    .card {
      min-width: 105px;
      height: 140px;
      border-radius: 14px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    }
    
    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.25);
    }
    
    .card.selected {
      transform: translateY(-12px);
      box-shadow: 0 14px 35px rgba(0,0,0,0.3);
    }
    
    .card-icon { font-size: 28px; margin-bottom: 6px; }
    .card-name { font-size: 13px; font-weight: 600; margin-bottom: 3px; }
    .card-desc { font-size: 10px; opacity: 0.85; line-height: 1.3; }
    
    .card-share { background: linear-gradient(135deg, #4CAF50, #66BB6A); color: #fff; }
    .card-evaluate { background: linear-gradient(135deg, #2196F3, #42A5F5); color: #fff; }
    .card-wish { background: linear-gradient(135deg, #E91E63, #EC407A); color: #fff; }
    .card-reverse { background: linear-gradient(135deg, #FF9800, #FFB74D); color: #fff; }
    .card-explain { background: linear-gradient(135deg, #9C27B0, #AB47BC); color: #fff; }
    .card-avoid { background: linear-gradient(135deg, #607D8B, #78909C); color: #fff; }
    .card-wild { background: linear-gradient(135deg, #FFD700, #FFC107); color: #333; }
    .card-delay { background: linear-gradient(135deg, #795548, #8D6E63); color: #fff; }
    
    /* 操作区 */
    .action-area {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 18px;
      margin-bottom: 16px;
    }
    
    .action-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      text-align: center;
    }
    
    .question-display {
      background: #f8f9fa;
      border-radius: 14px;
      padding: 18px;
      text-align: center;
      margin-bottom: 16px;
    }
    
    .question-type {
      font-size: 13px;
      color: var(--primary);
      font-weight: 600;
      margin-bottom: 6px;
    }
    
    .question-text {
      font-size: 17px;
      font-weight: 500;
      line-height: 1.5;
    }
    
    /* 玩家状态条 */
    .players-bar {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
      overflow-x: auto;
    }
    
    .player-chip {
      flex: 1;
      min-width: 100px;
      background: rgba(255,255,255,0.9);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-chip.inactive { opacity: 0.5; }
    .player-chip.current {
      background: #fff;
      box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    }
    
    .chip-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    
    .chip-info { flex: 1; }
    .chip-name { font-size: 12px; font-weight: 600; }
    .chip-status { font-size: 10px; color: var(--text-light); }
    .chip-emotion { font-size: 16px; }
    
    /* AI 分析面板 */
    .ai-panel {
      background: linear-gradient(135deg, rgba(103, 58, 183, 0.95), rgba(156, 39, 176, 0.95));
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 16px;
      color: #fff;
    }
    
    .ai-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .ai-insight-item {
      background: rgba(255,255,255,0.15);
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 10px;
    }
    
    .ai-insight-item:last-child { margin-bottom: 0; }
    
    .ai-insight-label {
      font-size: 11px;
      opacity: 0.8;
      margin-bottom: 4px;
    }
    
    .ai-insight-content {
      font-size: 13px;
      line-height: 1.4;
    }
    
    .ai-loading {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    
    .ai-loading .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .player-emotions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }
    
    .player-emotion-card {
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }
    
    .player-emotion-name { font-size: 11px; opacity: 0.8; margin-bottom: 4px; }
    .player-emotion-emoji { font-size: 20px; margin-bottom: 2px; }
    .player-emotion-word { font-size: 11px; font-weight: 500; }
    
    /* 记录面板 */
    .records-panel {
      background: rgba(255,255,255,0.95);
      border-radius: 16px;
      padding: 16px;
    }
    
    .records-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .record-item {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 8px;
    }
    
    .record-item:last-child { margin-bottom: 0; }
    
    .record-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    
    .record-player { font-size: 12px; font-weight: 600; color: var(--primary); }
    .record-card { font-size: 11px; color: var(--text-light); }
    .record-content { font-size: 13px; line-height: 1.4; }
    
    .empty-records {
      text-align: center;
      color: var(--text-light);
      padding: 20px;
      font-size: 13px;
    }
    
    /* ========== 总结页 ========== */
    .summary-content {
      flex: 1;
      overflow-y: auto;
    }
    
    .summary-card {
      background: linear-gradient(135deg, #60b3df, #764ba2);
      border-radius: 16px;
      padding: 20px;
      color: #fff;
      margin-bottom: 16px;
    }
    
    .summary-title {
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }
    
    .summary-section {
      background: rgba(255,255,255,0.15);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 12px;
    }
    
    .summary-section:last-child { margin-bottom: 0; }
    
    .summary-section-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .summary-list {
      font-size: 13px;
      line-height: 1.6;
    }
    
    .ai-summary-text {
      font-size: 16px;
      line-height: 1.7;
      white-space: pre-wrap;
    }
    
    .encouragement-card {
      background: linear-gradient(135deg, #11998e, #38ef7d);
      border-radius: 16px;
      padding: 20px;
      color: #fff;
    }
    
    .encouragement-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      text-align: center;
    }
    
    .encouragement-text {
      font-size: 14px;
      line-height: 1.7;
      text-align: center;
    }
    
    /* 心愿池卡片样式 */
    .wish-pool-card {
      background: linear-gradient(135deg, #f093fb, #f5576c);
      border-radius: 16px;
      padding: 20px;
      color: #fff;
      margin-bottom: 16px;
    }
    
    .wish-pool-title {
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 16px;
    }
    
    .wish-pool-list {
      background: rgba(255,255,255,0.15);
      border-radius: 12px;
      padding: 14px;
    }
    
    .wish-item {
      font-size: 14px;
      line-height: 1.8;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
    
    .wish-item:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }
    
    /* ========== 弹窗 ========== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.6);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .modal-overlay.show { display: flex; }
    
    .modal-content {
      background: #fff;
      border-radius: 20px;
      padding: 24px;
      width: 100%;
      max-width: 380px;
      animation: modalIn 0.3s ease;
    }
    
    @keyframes modalIn {
      from { opacity: 0; transform: scale(0.9) translateY(20px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }
    
    .modal-icon { font-size: 44px; text-align: center; margin-bottom: 14px; }
    .modal-title { font-size: 20px; font-weight: 600; text-align: center; margin-bottom: 10px; }
    .modal-desc {
      font-size: 14px;
      color: var(--text-light);
      text-align: center;
      line-height: 1.5;
      margin-bottom: 18px;
    }
    
    .modal-input {
      width: 100%;
      padding: 12px 14px;
      border: 2px solid #eee;
      border-radius: 12px;
      font-size: 15px;
      margin-bottom: 14px;
      resize: none;
    }
    
    .modal-input:focus {
      outline: none;
      border-color: var(--primary);
    }
    
    /* 语音输入按钮 */
    .voice-input-wrapper {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      margin-bottom: 14px;
    }
    
    .voice-input-wrapper .modal-input {
      flex: 1;
      margin-bottom: 0;
    }
    
    .voice-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }
    
    .voice-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(92, 107, 192, 0.4);
    }
    
    .voice-btn.recording {
      background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
      animation: pulse-voice 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse-voice {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.4); }
      50% { box-shadow: 0 0 0 15px rgba(255, 107, 107, 0); }
    }
    
    .voice-btn svg {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }
    
    .voice-status {
      font-size: 12px;
      color: var(--text-light);
      text-align: center;
      margin-bottom: 10px;
      min-height: 18px;
    }
    
    .voice-status.recording {
      color: #ff6b6b;
      font-weight: 500;
    }
    
    /* 导航底栏 */
    .nav-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(255,255,255,0.98);
      padding: 12px 20px;
      display: flex;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
      z-index: 100;
    }
    
    .nav-btn {
      padding: 10px 24px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .nav-btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: #fff;
    }
    
    .nav-btn-secondary {
      background: #f0f0f0;
      color: var(--text);
    }
    
    /* ========== 玩家切换动画遮罩 ========== */
    .turn-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      animation: fadeIn 0.3s ease;
    }
    
    .turn-overlay.show {
      display: flex;
    }
    
    .turn-avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 50px;
      margin-bottom: 20px;
      animation: bounceIn 0.5s ease;
    }
    
    .turn-text {
      color: #fff;
      font-size: 28px;
      font-weight: 700;
      text-align: center;
      margin-bottom: 10px;
      animation: slideUp 0.5s ease 0.2s both;
    }
    
    .turn-hint {
      color: rgba(255,255,255,0.8);
      font-size: 16px;
      text-align: center;
      animation: slideUp 0.5s ease 0.3s both;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes bounceIn {
      0% { transform: scale(0); opacity: 0; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    
    /* ========== 万能牌选择弹窗 ========== */
    .wild-card-options {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
      justify-content: center;
    }
    
    .wild-option {
      flex: 0 0 calc(50% - 6px);
      max-width: calc(50% - 6px);
      padding: 16px;
      border: 2px solid #eee;
      border-radius: 12px;
      background: #fff;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
    }
    
    .wild-option:hover {
      border-color: var(--primary);
      background: #f8f9ff;
    }
    
    .wild-option.selected {
      border-color: var(--primary);
      background: linear-gradient(135deg, #EDE7F6, #E8EAF6);
    }
    
    .wild-option-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }
    
    .wild-option-name {
      font-size: 14px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- 页面1: 设置页 -->
    <div id="page-setup" class="page active">
      <div class="page-header">
        <h1 class="page-title">深度对话助手</h1>
        <p class="page-subtitle">用卡牌打开心扉，让爱流动</p>
      </div>
      
      <div class="content-card">
        <h2 class="setup-title">游戏设置</h2>
        
        <div class="player-count-section">
          <label class="section-label">选择玩家人数</label>
          <div class="count-options">
            <button class="count-btn" onclick="setPlayerCount(2)">2人</button>
            <button class="count-btn active" onclick="setPlayerCount(3)">3人</button>
            <button class="count-btn" onclick="setPlayerCount(4)">4人</button>
            <button class="count-btn" onclick="setPlayerCount(5)">5人</button>
            <button class="count-btn" onclick="setPlayerCount(6)">6人</button>
          </div>
        </div>
        
        <div class="player-inputs" id="player-inputs"></div>
        
        <button class="btn btn-primary" onclick="goToRules()">下一步</button>
      </div>
    </div>
    
    <!-- 页面2: 入游须知 -->
    <div id="page-rules" class="page">
      <div class="page-header">
        <h1 class="page-title">入游须知</h1>
        <p class="page-subtitle">开始前，请全员确认以下共识</p>
      </div>
      
      <div class="content-card">
        <div class="rule-item">
          <div class="rule-icon">&#9878;&#65039;</div>
          <div class="rule-content">
            <h3>关系平等</h3>
            <p>在游戏中，没有"父母权威"或"子女身份"，每个人都是平等的对话者。</p>
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">&#128142;</div>
          <div class="rule-content">
            <h3>真诚前提</h3>
            <p>所有参与者都默认：希望通过这次游戏，进行一次深入而真实的交流。</p>
          </div>
        </div>
        
        <div class="rule-item">
          <div class="rule-icon">&#129323;</div>
          <div class="rule-content">
            <h3>绝对禁止打断</h3>
            <p>游戏中任何形式的打断发言都被禁止，请耐心倾听。</p>
          </div>
        </div>
        
        <div class="confirm-section">
          <p class="confirm-hint">请每位玩家依次点击确认</p>
          <div class="confirm-avatars" id="confirm-avatars"></div>
        </div>
        
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="goToSetup()">返回</button>
          <button class="btn btn-primary" id="btn-to-cards" onclick="goToCardSelect()" disabled>
            全员确认后开始游戏
          </button>
        </div>
      </div>
    </div>
    
    <!-- 页面3: 功能牌选择 -->
    <div id="page-cards" class="page">
      <div class="page-header">
        <h1 class="page-title">选择功能牌</h1>
        <p class="page-subtitle" id="card-select-hint">请选择2张功能牌</p>
      </div>
      
      <div class="content-card">
        <div class="selector-info">
          <div class="selector-avatar" id="selector-avatar">&#128104;</div>
          <div class="selector-name" id="selector-name">玩家</div>
          <div class="selector-progress" id="selector-progress">已选 0/2</div>
        </div>
        
        <div class="function-cards-grid" id="function-cards-grid"></div>
        
        <button class="btn btn-primary" id="btn-confirm-cards" onclick="confirmCardSelection()" disabled>
          确认选择
        </button>
      </div>
    </div>
    
    <!-- 页面4: 游戏主界面 -->
    <div id="page-game" class="page">
      <div class="players-bar" id="players-bar"></div>
      
      <div class="game-header">
        <div class="current-player">
          <div class="current-avatar" id="current-avatar">&#128104;</div>
          <div class="current-info">
            <h3 id="current-name">玩家</h3>
            <p>轮到你出牌</p>
          </div>
        </div>
        <div class="round-info">
          <div class="round-number" id="round-number">1</div>
          <div class="round-label">当前轮次</div>
        </div>
      </div>
      
      <div class="hand-section">
        <div class="section-title">&#127183; 你的手牌（点击选择）</div>
        <div class="hand-cards" id="hand-cards"></div>
      </div>
      
      <div class="action-area" id="action-area" style="display: none;">
        <div class="action-title" id="action-title">请选择一张牌出牌</div>
        <div class="question-display" id="question-display" style="display: none;">
          <div class="question-type" id="question-type">分享牌</div>
          <div class="question-text" id="question-text">问题内容</div>
        </div>
        <div class="btn-group">
          <button class="btn btn-primary" id="btn-confirm" onclick="confirmPlay()" disabled>确认出牌</button>
          <button class="btn btn-accent" onclick="nextTurn()">结束出牌</button>
        </div>
      </div>
      
      <div class="ai-panel" id="ai-panel">
        <div class="ai-title">&#129302; AI 记录官洞察</div>
        <div class="ai-insight-item">
          <div class="ai-insight-label">各位玩家心理状态</div>
          <div class="player-emotions-grid" id="player-emotions"></div>
        </div>
        <div class="ai-insight-item">
          <div class="ai-insight-label">AI 洞察</div>
          <div class="ai-insight-content" id="ai-insight">等待对话开始...</div>
        </div>
        <button class="btn btn-secondary" style="margin-top: 12px;" onclick="goToSummary()">查看对话总结</button>
      </div>
      
      <div class="records-panel">
        <div class="records-title">&#128221; 对话记录</div>
        <div id="records-list">
          <div class="empty-records">还没有对话记录，出牌开始吧！</div>
        </div>
      </div>
    </div>
    
    <!-- 页面5: 总结页 -->
    <div id="page-summary" class="page">
      <div class="page-header">
        <h1 class="page-title">对话总结</h1>
        <p class="page-subtitle">AI 为本次对话生成的总结</p>
      </div>
      
      <div class="content-card">
        <div class="summary-content" id="summary-content">
          <div class="ai-loading" id="summary-loading">
            <div class="spinner"></div>
            <span>AI 正在生成总结...</span>
          </div>
        </div>
        
        <div class="btn-group">
          <button class="btn btn-secondary" onclick="goToGame()">返回游戏</button>
          <button class="btn btn-primary" onclick="restartGame()">开始新游戏</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- 回答弹窗 -->
  <div class="modal-overlay" id="modal-answer">
    <div class="modal-content">
      <div class="modal-icon" id="modal-icon">&#128172;</div>
      <div class="modal-title" id="modal-title">分享时刻</div>
      <div class="modal-desc" id="modal-question">请回答问题</div>
      <div class="voice-status" id="voice-status-answer"></div>
      <div class="voice-input-wrapper">
        <textarea class="modal-input" id="modal-input" rows="4" placeholder="说出你的想法..."></textarea>
        <button class="voice-btn" id="voice-btn-answer" onclick="toggleVoiceInput('answer')" title="语音输入">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
            <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
          </svg>
        </button>
      </div>
      <button class="btn btn-primary" onclick="submitAnswer()">提交</button>
    </div>
  </div>
  
  <!-- 评价弹窗 -->
  <div class="modal-overlay" id="modal-evaluate">
    <div class="modal-content">
      <div class="modal-icon">&#128173;</div>
      <div class="modal-title">评价时刻</div>
      <div class="modal-desc">请对 <strong id="evaluate-target-name">某人</strong> 说出2个优点和2个缺点</div>
      <div class="voice-status" id="voice-status-evaluate"></div>
      <div class="voice-input-wrapper">
        <textarea class="modal-input" id="evaluate-content" rows="5" placeholder="写下你的评价..."></textarea>
        <button class="voice-btn" id="voice-btn-evaluate" onclick="toggleVoiceInput('evaluate')" title="语音输入">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
            <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
          </svg>
        </button>
      </div>
      <button class="btn btn-primary" onclick="submitEvaluate()">提交</button>
    </div>
  </div>
  
  <!-- 万能牌选择弹窗 -->
  <div class="modal-overlay" id="modal-wild">
    <div class="modal-content">
      <div class="modal-icon">&#10024;</div>
      <div class="modal-title">万能牌</div>
      <div class="modal-desc">选择你想变成的牌类型</div>
      <div class="wild-card-options">
        <!-- 动态生成选项 -->
      </div>
      <button class="btn btn-primary" id="btn-wild-confirm" onclick="confirmWildSelection()" disabled>确认选择</button>
    </div>
  </div>
  
  <!-- 玩家切换动画遮罩 -->
  <div class="turn-overlay" id="turn-overlay">
    <div class="turn-avatar" id="turn-avatar">&#128104;</div>
    <div class="turn-text" id="turn-text">轮到 玩家 出牌</div>
    <div class="turn-hint">请将手机交给该玩家</div>
  </div>

  <script>
    // ========== API 配置 ==========
    const API_URL = "/api/chat";
    const MODEL = "Qwen/Qwen2.5-72B-Instruct";
    
    // ========== 游戏状态 ==========
    let players = [];
    let currentPlayerIndex = 0;
    let round = 1;
    let selectedCard = null;
    let records = [];
    let wishes = [];
    let playerCount = 3;
    let pendingCard = null;
    let playDirection = 1;
    let wishCardGiven = false;
    let confirmedPlayers = [];
    let cardSelectingPlayer = 0;
    let selectedFunctionCards = [];
    let playerEmotions = {}; // 存储AI分析的玩家心理状态
    let lastAIAnalysis = null;
    let analysisInProgress = false;
    let selectedWildType = null; // 万能牌选择的类型
    let lastPlayerIndex = -1; // 上一个玩家索引，用于判断是否需要显示切换动画
    
    const avatars = ['&#128104;', '&#128105;', '&#129489;', '&#128116;', '&#128117;', '&#129490;'];
    const avatarColors = ['#FFE0B2', '#F8BBD9', '#B3E5FC', '#C8E6C9', '#E1BEE7', '#FFCCBC'];
    const defaultNames = ['爸爸', '妈妈', '我', '爷爷', '奶奶', '弟弟/妹妹'];
    
    const functionCardTypes = ['reverse', 'explain', 'avoid', 'wild'];
    
    const cardTypes = {
      share: { name: '分享牌', icon: '&#128172;', desc: '回答AI随机生成的问题', class: 'card-share' },
      evaluate: { name: '评价牌', icon: '&#128173;', desc: '说出对方2个优点+2个缺点', class: 'card-evaluate' },
      wish: { name: '心愿牌', icon: '&#127775;', desc: '说出并记录一个心愿', class: 'card-wish' },
      reverse: { name: '反转牌', icon: '&#128260;', desc: '让出牌人回答问题', class: 'card-reverse' },
      explain: { name: '解释牌', icon: '&#128226;', desc: '要求下家进行补充澄清', class: 'card-explain' },
      avoid: { name: '回避牌', icon: '&#128584;', desc: '选择不回答当前问题', class: 'card-avoid' },
      wild: { name: '万能牌', icon: '&#10024;', desc: '变成一张牌自己使用', class: 'card-wild' }
    };
    
    // 深度问题话题
    /*
    工作/学习篇
1. 工作/学习中，最近一次感受到被认可的瞬间是什么样的？
2. 现阶段的工作/学习里，有哪个小细节会让你觉得做起来很舒心？
3. 如果给当下的工作/学习加一个“小期待”，你会希望是什么？
4. 工作/学习中，有没有一件小事，做完后让你觉得很有成就感？
5. 最近在工作/学习上，有没有遇到过一个温柔的小帮助？
6. 工作 / 学习中，有没有哪个瞬间让你想轻轻停下，好好感受当下的美好？
7. 现阶段的工作 / 学习里，你收获的一个小成长是什么，哪怕只是很小的一点？
8. 你心里最舒服的工作 / 学习氛围，会有什么样的小特征？
9. 为了让工作 / 学习更顺心，你有没有为自己做过什么小调整？
10. 对接下来的工作 / 学习，有没有一个不用太费力的小期待？
11. 工作 / 学习时，有没有一个小物件能让你觉得安心、有力量？
友谊篇
1. 和朋友相处时，哪一个小细节会让你觉得特别温暖？
2. 最近一次和朋友聊天，哪句话让你觉得心里暖暖的？
3. 你觉得一段舒服的友谊，最离不开的一个特质是什么？
4. 有没有一个朋友的小习惯，会让你觉得TA很特别、很可爱？
5. 想起某个朋友时，最先浮现在你脑海的是一个什么样的画面？
6. 你和朋友之间，有没有一个专属小默契，想起就觉得特别美好？
7. 最近一次被朋友精准理解你的小情绪，是因为什么事？
8. 和朋友相处时，哪一个轻松的瞬间，让你觉得 “有朋友真好”？
9. 心里藏着的小小心愿，有没有想过和某个朋友一起实现？
10. 朋友带给你的，最珍贵的一点小力量是什么？
11. 想起和朋友的过往，哪一个温暖的小片段会让你不自觉笑起来？
亲情篇
1. 家人的哪一个小举动，曾悄悄治愈过你？
2. 最近一次和家人好好聊天，你们聊了些什么轻松的话题？
3. 你觉得家人表达关心的方式，哪一点最贴合你的心意？
4. 想起家人时，最让你觉得安心的一个瞬间是什么？
5. 有没有一句想对家人说，却还没来得及说的温柔话？
6. 和家人相处的日常里，哪一个平凡的小画面，让你觉得格外珍贵？
7. 家人的哪一个小优点，是你一直以来都很欣赏的？
8. 有没有一件想和家人一起做的小事，一直放在心里？
9. 你曾有过的小任性，被家人温柔包容的瞬间，还记得吗？
10. 家人说过的哪一句话，你悄悄记了很久，想起就觉得温暖？
11. 在外奔波时，哪一个关于家人的小念想，能让你瞬间安心？
通用暖心篇
1. 这阵子，让你觉得“生活很美好”的一个小瞬间是什么？
2. 最近吃到的哪一样东西，让你觉得味蕾被治愈了？
3. 你觉得 “好好生活” 的样子，藏在哪个小细节里？
4. 这一年，你为自己做的最温柔的一件小事是什么？
5. 如果给自己的当下状态打个温柔的标签，你会选什么？
6. 最近一次觉得“被好好爱着”，是因为什么事？
7. 有没有一个小地方，去到那里会让你觉得特别放松、有归属感？
8. 最近一次被自然里的小美好打动，是看到了晚霞、清风还是路边的小花？
9. 你有什么专属的 “小治愈仪式”，难过或疲惫时会下意识去做？
10. 有没有一个小众的小爱好，做起来会让你完全沉浸、忘记时间？
11. 最近一次好好照顾自己，是为自己做了一件什么小事？
12. 心里觉得疲惫时，什么样的小陪伴会让你觉得被安抚？
自我感受篇
1. 这阵子，你的情绪里最常出现的一种温柔感受是什么？
2. 你有没有一个专属的 “快乐小开关”，一碰就能开心一点？
3. 对现在的自己，你想说出的一句温柔肯定是什么？
4. 最近一次发现自己的小进步，是在什么时刻？
5. 心里的小美好，你会用什么方式悄悄收藏起来？
    */
    const topicTrees = {
      happiness: {
        name: '快乐时刻',
        questions: [
          '最近吃到的哪一样东西，让你觉得味蕾被治愈了？',
          '最近一次觉得“被好好爱着”，是因为什么事？',
          '你有没有一个专属的 “快乐小开关”，一碰就能开心一点？'
        ],
        counter : 0
      },
      gratitude: {
        name: '感恩之心',
        questions: [
          '今年最想感谢的人是谁？',
          '最近有没有遇到过一些温柔的小帮助？',
          '有没有一个小地方，去到那里会让你觉得特别放松、有归属感？'
        ],
        counter : 0
      },
      family: {
        name: '家的温度',
        questions: [
          '家人的哪一个小优点，是你一直以来都很欣赏的？',
          '你觉得家人表达关心的方式，哪一点最贴合你的心意？',
          '有没有一句想对家人说，却还没来得及说的温柔话？'
        ],
        counter : 0
      },
      growth: {
        name: '成长领悟',
        questions: [
          '最近最大的收获或成长是什么？',
          '最近一次发现自己的小进步，是在什么时刻？',
          '有没有一些小事，做完后让你觉得很有成就感？'
        ],
        counter : 0
      },
      unsaid: {
        name: '未说出口的话',
        questions: [
          '有没有一句想对家人说，却还没来得及说的温柔话？',
          '平时是什么会让你一直难以说出某句话？',
          '趁现在，你愿意试着说出来一句你未曾启齿的话吗？'
        ],
        counter : 0
      },
      pressure: {
        name: '压力与释放',
        questions: [
          '最近让你感到压力最大的事是什么？',
          '如果给自己的当下状态打个温柔的标签，你会选什么？',
          '这阵子，你的情绪里最常出现的一种温柔感受是什么？'
        ],
        counter : 0
      }
    };
    
    // ========== 页面导航 ==========
    function showPage(pageId) {
      console.log('切换到页面:', pageId);
      
      // 隐藏所有页面
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });
      
      // 显示目标页面
      const nextPage = document.getElementById('page-' + pageId);
      if (nextPage) {
        nextPage.classList.add('active');
        console.log('页面已激活:', pageId);
      } else {
        console.error('找不到页面:', pageId);
      }
    }
    
    function goToSetup() { showPage('setup'); }
    function goToRules() {
      initPlayers();
      renderConfirmAvatars();
      showPage('rules');
    }
    function goToCardSelect() {
      console.log('goToCardSelect called, confirmedPlayers:', confirmedPlayers.length, 'players:', players.length);
      if (confirmedPlayers.length !== players.length) {
        console.log('条件不满足，返回');
        return;
      }
      // 跳过功能牌选择页面，直接开始游戏（随机发牌）
      startGame();
    }
    function goToGame() { showPage('game'); }
    function goToSummary() {
      showPage('summary');
      generateAISummary();
    }
    
    // ========== 设置页逻辑 ==========
    function initPlayerInputs() {
      const container = document.getElementById('player-inputs');
      container.innerHTML = '';
      
      for (let i = 0; i < playerCount; i++) {
        container.innerHTML += `
          <div class="player-input">
            <div class="player-avatar" style="background: ${avatarColors[i]}">${avatars[i]}</div>
            <input type="text" id="player${i+1}" placeholder="玩家${i+1}（如：${defaultNames[i]}）">
          </div>
        `;
      }
    }
    
    function setPlayerCount(count) {
      playerCount = count;
      document.querySelectorAll('.count-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent === count + '人') btn.classList.add('active');
      });
      initPlayerInputs();
    }
    
    function initPlayers() {
      players = [];
      for (let i = 0; i < playerCount; i++) {
        const input = document.getElementById(`player${i+1}`);
        const name = input ? input.value.trim() || `玩家${i+1}` : `玩家${i+1}`;
        players.push({
          name: name,
          avatar: avatars[i],
          color: avatarColors[i],
          cards: [],
          functionCards: [],
          active: true
        });
        playerEmotions[name] = { emoji: '&#128566;', word: '等待' };
      }
    }
    
    // ========== 入游须知页逻辑 ==========
    function renderConfirmAvatars() {
      const container = document.getElementById('confirm-avatars');
      container.innerHTML = players.map((p, i) => `
        <div class="confirm-avatar ${confirmedPlayers.includes(i) ? 'confirmed' : ''}" 
             style="background: ${p.color}" 
             onclick="confirmPlayer(${i})">
          <span class="confirm-avatar-emoji">${p.avatar}</span>
          <span class="confirm-avatar-name">${p.name}</span>
        </div>
      `).join('');
      
      const btn = document.getElementById('btn-to-cards');
      if (confirmedPlayers.length === players.length) {
        btn.disabled = false;
        btn.textContent = '全员已确认，开始游戏';
      } else {
        btn.disabled = true;
        btn.textContent = `还需 ${players.length - confirmedPlayers.length} 人确认`;
      }
    }
    
    function confirmPlayer(index) {
      if (confirmedPlayers.includes(index)) {
        confirmedPlayers = confirmedPlayers.filter(i => i !== index);
      } else {
        confirmedPlayers.push(index);
      }
      renderConfirmAvatars();
    }
    
    // ========== 功能牌选择页逻辑 ==========
    function renderCardSelection() {
      const player = players[cardSelectingPlayer];
      selectedFunctionCards = [];
      
      document.getElementById('selector-avatar').innerHTML = player.avatar;
      document.getElementById('selector-avatar').style.background = player.color;
      document.getElementById('selector-name').textContent = player.name;
      document.getElementById('card-select-hint').textContent = `${player.name}，请选择2张功能牌`;
      
      // 先渲染功能牌
      const grid = document.getElementById('function-cards-grid');
      grid.innerHTML = functionCardTypes.map(type => {
        const card = cardTypes[type];
        return `
          <div class="func-card" id="func-${type}" onclick="toggleFunctionCard('${type}')">
            <div class="func-card-icon">${card.icon}</div>
            <div class="func-card-name">${card.name}</div>
            <div class="func-card-desc">${card.desc}</div>
          </div>
        `;
      }).join('');
      
      // 然后再更新进度（此时 DOM 元素已存在）
      updateCardSelectProgress();
    }
    
    function toggleFunctionCard(type) {
      const card = document.getElementById(`func-${type}`);
      if (card.classList.contains('disabled')) return;
      
      if (selectedFunctionCards.includes(type)) {
        selectedFunctionCards = selectedFunctionCards.filter(t => t !== type);
        card.classList.remove('selected');
      } else if (selectedFunctionCards.length < 2) {
        selectedFunctionCards.push(type);
        card.classList.add('selected');
      }
      updateCardSelectProgress();
    }
    
    function updateCardSelectProgress() {
      document.getElementById('selector-progress').textContent = `已选 ${selectedFunctionCards.length}/2`;
      
      const btn = document.getElementById('btn-confirm-cards');
      btn.disabled = selectedFunctionCards.length !== 2;
      btn.textContent = selectedFunctionCards.length === 2 ? '确认选择' : `还需选 ${2 - selectedFunctionCards.length} 张`;
      
      functionCardTypes.forEach(type => {
        const card = document.getElementById(`func-${type}`);
        if (selectedFunctionCards.length >= 2 && !selectedFunctionCards.includes(type)) {
          card.classList.add('disabled');
        } else {
          card.classList.remove('disabled');
        }
      });
    }
    
    function confirmCardSelection() {
      if (selectedFunctionCards.length !== 2) return;
      
      players[cardSelectingPlayer].functionCards = [...selectedFunctionCards];
      cardSelectingPlayer++;
      
      if (cardSelectingPlayer < players.length) {
        renderCardSelection();
      } else {
        startGame();
      }
    }
    
    // ========== 游戏逻辑 ==========
    function startGame() {
      playDirection = 1;
      wishCardGiven = false;
      records = [];
      wishes = [];
      round = 1;
      currentPlayerIndex = 0;
      lastPlayerIndex = -1;
      
      // 随机发牌策略
      distributeCards();
      
      pendingCard = null;
      showPage('game');
      updateGameUI();
    }
    
    // 随机发牌函数
    function distributeCards() {
      const playerNum = players.length;
      const contentPerPlayer = 3; // 每人3张内容牌
      const functionPerPlayer = 2; // 每人2张功能牌
      
      // 创建内容牌池（心愿牌全场只有1张）
      let contentPool = [];
      const totalContentNeeded = playerNum * contentPerPlayer;
      // 1张心愿牌，其余平分给分享牌和评价牌
      const remainingContent = totalContentNeeded - 1;
      const shareCount = Math.ceil(remainingContent / 2);
      const evaluateCount = remainingContent - shareCount;
      
      contentPool.push({ type: 'wish' }); // 唯一的心愿牌
      for (let i = 0; i < shareCount; i++) {
        contentPool.push({ type: 'share' });
      }
      for (let i = 0; i < evaluateCount; i++) {
        contentPool.push({ type: 'evaluate' });
      }
      
      // 创建功能牌池（万能牌全场只有1张）
      let functionPool = [];
      const totalFunctionNeeded = playerNum * functionPerPlayer;
      // 1张万能牌，其余平分给反转、解释、回避牌
      const remainingFunction = totalFunctionNeeded - 1;
      const perTypeCount = Math.floor(remainingFunction / 3);
      const extraCards = remainingFunction % 3;
      
      functionPool.push({ type: 'wild' }); // 唯一的万能牌
      for (let i = 0; i < perTypeCount + (extraCards > 0 ? 1 : 0); i++) {
        functionPool.push({ type: 'reverse' });
      }
      for (let i = 0; i < perTypeCount + (extraCards > 1 ? 1 : 0); i++) {
        functionPool.push({ type: 'explain' });
      }
      for (let i = 0; i < perTypeCount; i++) {
        functionPool.push({ type: 'avoid' });
      }
      
      // 洗牌（Fisher-Yates算法确保随机性）
      shuffleArray(contentPool);
      shuffleArray(functionPool);
      
      // 为每个玩家发牌：每人3张内容牌 + 2张功能牌
      players.forEach(player => {
        player.cards = [];
        playerEmotions[player.name] = { emoji: '&#128566;', word: '等待' };
        
        // 发3张内容牌
        for (let i = 0; i < contentPerPlayer && contentPool.length > 0; i++) {
          player.cards.push(contentPool.pop());
        }
        
        // 发2张功能牌
        for (let i = 0; i < functionPerPlayer && functionPool.length > 0; i++) {
          player.cards.push(functionPool.pop());
        }
        
        // 打乱玩家手牌顺序，增加随机性
        shuffleArray(player.cards);
      });
      
      console.log('发牌完成，各玩家手牌:', players.map(p => ({name: p.name, cards: p.cards.map(c => c.type)})));
    }
    
    // 洗牌函数（Fisher-Yates算法）
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    
    function updateGameUI() {
      const current = players[currentPlayerIndex];
      
      // 检查是否需要显示玩家切换动画
      if (lastPlayerIndex !== -1 && lastPlayerIndex !== currentPlayerIndex) {
        showTurnAnimation(current);
      }
      lastPlayerIndex = currentPlayerIndex;
      
      document.getElementById('current-avatar').innerHTML = current.avatar;
      document.getElementById('current-avatar').style.background = current.color;
      document.getElementById('current-name').textContent = current.name;
      document.getElementById('round-number').textContent = round;
      
      updatePlayersBar();
      updateHandCards();
      
      selectedCard = null;
      document.getElementById('btn-confirm').disabled = true;
      
      if (pendingCard) {
        showPendingCard();
      } else {
        showNormalActionArea();
      }
    }
    
    // 显示正常的操作区域（无待处理牌时）
    function showNormalActionArea() {
      document.getElementById('action-area').style.display = 'block';
      document.getElementById('action-title').textContent = '请选择一张牌出牌';
      document.getElementById('question-display').style.display = 'none';
      
      const btnGroup = document.querySelector('#action-area .btn-group');
      btnGroup.innerHTML = `
        <button class="btn btn-primary" id="btn-confirm" onclick="confirmPlay()" disabled>确认出牌</button>
        <button class="btn btn-accent" onclick="nextTurn()">结束出牌</button>
      `;
    }
    
    // 显示玩家切换动画
    function showTurnAnimation(player) {
      const overlay = document.getElementById('turn-overlay');
      document.getElementById('turn-avatar').innerHTML = player.avatar;
      document.getElementById('turn-avatar').style.background = player.color;
      document.getElementById('turn-text').textContent = `轮到 ${player.name} 出牌`;
      
      overlay.classList.add('show');
      
      // 2秒后自动关闭
      setTimeout(() => {
        overlay.classList.remove('show');
      }, 2000);
      
      // 点击任意位置关闭
      overlay.onclick = () => {
        overlay.classList.remove('show');
      };
    }
    
    function updatePlayersBar() {
      const bar = document.getElementById('players-bar');
      bar.innerHTML = players.map((p, i) => {
        const emotion = playerEmotions[p.name] || { emoji: '&#128566;', word: '等待' };
        return `
          <div class="player-chip ${!p.active ? 'inactive' : ''} ${i === currentPlayerIndex ? 'current' : ''}">
            <div class="chip-avatar" style="background: ${p.color}">${p.avatar}</div>
            <div class="chip-info">
              <div class="chip-name">${p.name}</div>
              <div class="chip-status">${p.active ? p.cards.length + '张牌' : '旁听'}</div>
            </div>
            <div class="chip-emotion" title="${emotion.word}">${emotion.emoji}</div>
          </div>
        `;
      }).join('');
    }
    
    function updateHandCards() {
      const current = players[currentPlayerIndex];
      const container = document.getElementById('hand-cards');
      
      container.innerHTML = current.cards.map((card, index) => {
        const type = cardTypes[card.type];
        return `
          <div class="card ${type.class}" onclick="selectCard(${index})" id="card-${index}">
            <div class="card-icon">${type.icon}</div>
            <div class="card-name">${type.name}</div>
            <div class="card-desc">${type.desc}</div>
          </div>
        `;
      }).join('');
    }
    
    function selectCard(index) {
      if (pendingCard) {
        alert('请先执行收到的牌');
        return;
      }
      
      const current = players[currentPlayerIndex];
      const card = current.cards[index];
      
      // 回避牌和反转牌不能主动出牌，只能在收到分享牌或评价牌时响应使用
      if (card.type === 'avoid') {
        alert('回避牌只能在收到分享牌或评价牌时使用，不能主动打出！');
        return;
      }
      if (card.type === 'reverse') {
        alert('反转牌只能在收到分享牌或评价牌时使用，不能主动打出！');
        return;
      }
      
      // 心愿牌是自己使用的，不是打给下家
      if (card.type === 'wish') {
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        document.getElementById('card-' + index).classList.add('selected');
        selectedCard = index;
        
        const type = cardTypes[card.type];
        document.getElementById('action-area').style.display = 'block';
        document.getElementById('action-title').textContent = `选中：${type.name}`;
        document.getElementById('btn-confirm').textContent = '许下心愿';
        document.getElementById('btn-confirm').disabled = false;
        document.getElementById('btn-confirm').onclick = executeWishCard;
        
        document.getElementById('question-display').style.display = 'block';
        document.getElementById('question-type').textContent = type.name;
        document.getElementById('question-text').textContent = '说出你的一个心愿，心愿牌将随机分给其他玩家';
        return;
      }
      
      // 万能牌也是自己使用的
      if (card.type === 'wild') {
        document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        document.getElementById('card-' + index).classList.add('selected');
        selectedCard = index;
        
        const type = cardTypes[card.type];
        document.getElementById('action-area').style.display = 'block';
        document.getElementById('action-title').textContent = `选中：${type.name}`;
        document.getElementById('btn-confirm').textContent = '使用万能牌';
        document.getElementById('btn-confirm').disabled = false;
        document.getElementById('btn-confirm').onclick = useWildCard;
        
        document.getElementById('question-display').style.display = 'block';
        document.getElementById('question-type').textContent = type.name;
        document.getElementById('question-text').textContent = '选择变成：分享/评价/解释/反转/回避牌';
        return;
      }
      
      document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
      document.getElementById('card-' + index).classList.add('selected');
      selectedCard = index;
      
      const type = cardTypes[card.type];
      const nextPlayer = getNextActivePlayer();
      
      document.getElementById('action-area').style.display = 'block';
      document.getElementById('action-title').textContent = `选中：${type.name}`;
      document.getElementById('btn-confirm').textContent = `发给 ${nextPlayer.name}`;
      document.getElementById('btn-confirm').disabled = false;
      document.getElementById('btn-confirm').onclick = confirmPlay;
      
      document.getElementById('question-display').style.display = 'block';
      document.getElementById('question-type').textContent = type.name;
      document.getElementById('question-text').textContent = `${nextPlayer.name} 将执行：${type.desc}`;
    }
    
    // 执行心愿牌（自己使用）
    function executeWishCard() {
      if (selectedCard === null) return;
      
      const current = players[currentPlayerIndex];
      
      // 移除心愿牌
      current.cards.splice(selectedCard, 1);
      selectedCard = null;
      
      // 显示心愿输入弹窗
      showAnswerModal('说出你的一个心愿', '心愿时刻', '&#127775;');
    }
    
    // 使用万能牌（打开选择弹窗）
    function useWildCard() {
      if (selectedCard === null) return;
      
      // 显示万能牌选择弹窗（显示场上所有可选牌类型）
      showWildCardModal();
    }
    
    // 显示万能牌选择弹窗（固定的5种牌类型）
    function showWildCardModal() {
      selectedWildType = null;
      
      // 万能牌可变成的固定牌类型（不包括心愿牌和万能牌本身）
      const availableTypes = ['share', 'evaluate', 'explain', 'reverse', 'avoid'];
      
      // 动态生成选项
      const optionsContainer = document.querySelector('.wild-card-options');
      optionsContainer.innerHTML = availableTypes.map(type => {
        const cardInfo = cardTypes[type];
        return `
          <div class="wild-option" onclick="selectWildOption('${type}')">
            <div class="wild-option-icon">${cardInfo.icon}</div>
            <div class="wild-option-name">${cardInfo.name}</div>
          </div>
        `;
      }).join('');
      
      document.getElementById('btn-wild-confirm').disabled = true;
      document.getElementById('modal-wild').classList.add('show');
    }
    
    function getNextActivePlayer() {
      let nextIndex = currentPlayerIndex;
      do {
        nextIndex = (nextIndex + playDirection + players.length) % players.length;
      } while (!players[nextIndex].active && nextIndex !== currentPlayerIndex);
      return players[nextIndex];
    }
    
    function getRandomQuestion() {
      const topics = Object.values(topicTrees);
      const topic = topics[Math.floor(Math.random() * topics.length)];
      const question = topic.questions[topic.counter % topic.questions.length];
      topic.counter++;
      return { text: question, topicName: topic.name };
    }
    
    function showPendingCard() {
      const type = cardTypes[pendingCard.type];
      const current = players[currentPlayerIndex];
      
      document.getElementById('action-area').style.display = 'block';
      document.getElementById('action-title').textContent = `${pendingCard.fromPlayer} 给你的牌`;
      document.getElementById('btn-confirm').textContent = '执行此牌';
      document.getElementById('btn-confirm').disabled = false;
      document.getElementById('btn-confirm').onclick = executePendingCard;
      
      // 检查是否可以使用回避牌或反转牌（只有收到分享牌或评价牌时才能使用）
      const hasAvoidCard = current.cards.some(c => c.type === 'avoid');
      const hasReverseCard = current.cards.some(c => c.type === 'reverse');
      const canUseResponseCard = pendingCard.type === 'share' || pendingCard.type === 'evaluate';
      
      // 更新按钮组，根据可用的响应牌显示按钮
      const btnGroup = document.querySelector('#action-area .btn-group');
      let buttonsHtml = '<button class="btn btn-primary" id="btn-confirm" onclick="executePendingCard()">执行此牌</button>';
      
      if (canUseResponseCard && hasReverseCard) {
        buttonsHtml += '<button class="btn btn-secondary" onclick="useReverseCard()">使用反转牌</button>';
      }
      if (canUseResponseCard && hasAvoidCard) {
        buttonsHtml += '<button class="btn btn-secondary" onclick="useAvoidCard()">使用回避牌</button>';
      }
      
      btnGroup.innerHTML = buttonsHtml;
      
      if (pendingCard.type === 'share') {
        // 只有在问题不存在时才生成新问题（反转牌时保留原问题）
        if (!pendingCard.question) {
          const q = getRandomQuestion();
          pendingCard.question = q.text;
          pendingCard.topicName = q.topicName;
        }
        document.getElementById('question-display').style.display = 'block';
        document.getElementById('question-type').textContent = `${type.name} - ${pendingCard.topicName}`;
        document.getElementById('question-text').textContent = pendingCard.question;
      } else if (pendingCard.type === 'wish') {
        document.getElementById('question-display').style.display = 'block';
        document.getElementById('question-type').textContent = type.name;
        document.getElementById('question-text').textContent = '说出你的一个心愿';
      } else if (pendingCard.type === 'evaluate') {
        document.getElementById('question-display').style.display = 'block';
        document.getElementById('question-type').textContent = type.name;
        document.getElementById('question-text').textContent = '评价一位在场的玩家';
      } else {
        document.getElementById('question-display').style.display = 'block';
        document.getElementById('question-type').textContent = type.name;
        document.getElementById('question-text').textContent = type.desc;
      }
    }
    
    // 使用反转牌 - 让出牌人执行这张牌
    function useReverseCard() {
      const current = players[currentPlayerIndex];
      const reverseIndex = current.cards.findIndex(c => c.type === 'reverse');
      
      if (reverseIndex === -1) {
        alert('你没有反转牌了！');
        return;
      }
      
      // 移除反转牌（不添加新牌）
      current.cards.splice(reverseIndex, 1);
      
      // 记录使用反转牌
      addRecord(current.name, '反转牌', `将${cardTypes[pendingCard.type].name}反转给 ${pendingCard.fromPlayer}`);
      
      // 检查游戏是否结束
      if (checkGameEnd()) return;
      
      // 直接把牌反转给原出牌人，让他执行
      const originalFromPlayerIndex = pendingCard.fromPlayerIndex;
      
      // 保留原问题内容（重要：反转后原出牌人要回答同一个问题）
      const savedQuestion = pendingCard.question;
      const savedTopicName = pendingCard.topicName;
      
      // 更新 pendingCard，fromPlayer 变为使用反转牌的人
      pendingCard.fromPlayer = current.name;
      pendingCard.fromPlayerIndex = currentPlayerIndex;
      pendingCard.question = savedQuestion;
      pendingCard.topicName = savedTopicName;
      
      // 切换到原出牌人
      currentPlayerIndex = originalFromPlayerIndex;
      
      // 更新UI，原出牌人需要执行被反转的牌
      updateGameUI();
    }
    
    // 使用回避牌
    function useAvoidCard() {
      const current = players[currentPlayerIndex];
      const avoidIndex = current.cards.findIndex(c => c.type === 'avoid');
      
      if (avoidIndex === -1) {
        alert('你没有回避牌了！');
        return;
      }
      
      // 移除回避牌（不添加新牌）
      current.cards.splice(avoidIndex, 1);
      
      // 记录使用回避牌
      addRecord(current.name, '回避牌', '选择不回答这个问题');
      
      // 检查游戏是否结束
      if (checkGameEnd()) return;
      
      // 清除待处理牌，直接进入下一回合
      pendingCard = null;
      nextTurn();
    }
    
    function executePendingCard() {
      if (!pendingCard) return;
      
      switch (pendingCard.type) {
        case 'share':
          showAnswerModal(pendingCard.question, '分享时刻', '&#128172;');
          break;
        case 'evaluate':
          showEvaluateModal();
          break;
        case 'wish':
          showAnswerModal('说出你的一个心愿', '心愿时刻', '&#127775;');
          break;
        case 'reverse':
          handleReverseCard();
          break;
        case 'avoid':
          handleAvoidCard();
          break;
        case 'explain':
          showAnswerModal('请补充或澄清你想说的内容', '解释时刻', '&#128226;');
          break;
        case 'wild':
          handleWildCard();
          break;
        default:
          showAnswerModal(`使用${cardTypes[pendingCard.type].name}`, cardTypes[pendingCard.type].name, cardTypes[pendingCard.type].icon);
      }
    }
    
    function handleReverseCard() {
      // 反转牌不能通过 executePendingCard 执行，只能通过 useReverseCard 响应使用
      alert('反转牌只能在收到分享牌或评价牌时使用！');
    }
    
    function handleAvoidCard() {
      // 回避牌不能通过 executePendingCard 执行，只能通过 useAvoidCard 响应使用
      alert('回避牌只能在收到分享牌或评价牌时使用！');
    }
    
    function handleWildCard() {
      // 显示万能牌选择弹窗
      selectedWildType = null;
      document.querySelectorAll('.wild-option').forEach(opt => opt.classList.remove('selected'));
      document.getElementById('btn-wild-confirm').disabled = true;
      document.getElementById('modal-wild').classList.add('show');
    }
    
    function selectWildOption(type) {
      selectedWildType = type;
      document.querySelectorAll('.wild-option').forEach(opt => opt.classList.remove('selected'));
      event.currentTarget.classList.add('selected');
      document.getElementById('btn-wild-confirm').disabled = false;
    }
    
    function confirmWildSelection() {
      if (!selectedWildType || selectedCard === null) return;
      document.getElementById('modal-wild').classList.remove('show');
      
      const current = players[currentPlayerIndex];
      
      // 移除万能牌
      current.cards.splice(selectedCard, 1);
      
      // 记录使用万能牌
      addRecord(current.name, '万能牌', `变成了${cardTypes[selectedWildType].name}`);
      
      // 检查游戏是否结束
      if (checkGameEnd()) return;
      
      selectedCard = null;
      
      // 万能牌变形后自己执行（不是发给下家）
      switch (selectedWildType) {
        case 'share':
          showAnswerModal(getRandomQuestion().text, '分享时刻', '&#128172;');
          break;
        case 'evaluate':
          // 评价牌：自己评价其他玩家
          showSelfEvaluateModal();
          break;
        case 'explain':
          showAnswerModal('请补充或澄清你想说的内容', '解释时刻', '&#128226;');
          break;
        case 'reverse':
        case 'avoid':
          // 反转牌和回避牌是响应牌，变成后加入手牌
          current.cards.push({ type: selectedWildType });
          alert(`万能牌已变成${cardTypes[selectedWildType].name}，已加入你的手牌！`);
          updateGameUI();
          break;
      }
      
      selectedWildType = null;
    }
    
    // 自己使用评价牌时的弹窗（选择要评价的玩家）
    function showSelfEvaluateModal() {
      // 获取其他玩家列表
      const otherPlayers = players.filter((p, i) => i !== currentPlayerIndex && p.active);
      if (otherPlayers.length === 0) {
        alert('没有其他玩家可以评价！');
        updateGameUI();
        return;
      }
      
      // 随机选择一个玩家进行评价
      const targetPlayer = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
      document.getElementById('evaluate-target-name').textContent = targetPlayer.name;
      document.getElementById('evaluate-content').value = '';
      
      // 标记这是自己使用评价牌
      pendingCard = { type: 'evaluate', fromPlayer: players[currentPlayerIndex].name, selfUse: true, targetPlayer: targetPlayer.name };
      
      document.getElementById('modal-evaluate').classList.add('show');
    }
    
    function confirmPlay() {
      if (selectedCard === null) return;
      
      const current = players[currentPlayerIndex];
      const card = current.cards[selectedCard];
      
      pendingCard = {
        type: card.type,
        fromPlayer: current.name,
        fromPlayerIndex: currentPlayerIndex
      };
      
      current.cards.splice(selectedCard, 1);
      selectedCard = null;
      
      // 检查游戏是否结束
      if (checkGameEnd()) return;
      
      nextTurn();
    }
    
    function showAnswerModal(question, title, icon) {
      document.getElementById('modal-icon').innerHTML = icon;
      document.getElementById('modal-title').textContent = title;
      document.getElementById('modal-question').textContent = question;
      document.getElementById('modal-input').value = '';
      document.getElementById('modal-answer').classList.add('show');
    }
    
    function showEvaluateModal() {
      const evaluateTarget = pendingCard ? pendingCard.fromPlayer : '某人';
      document.getElementById('evaluate-target-name').textContent = evaluateTarget;
      document.getElementById('evaluate-content').value = '';
      document.getElementById('modal-evaluate').classList.add('show');
    }
    
    function submitAnswer() {
      const content = document.getElementById('modal-input').value.trim();
      if (!content) {
        alert('请输入内容');
        return;
      }
      
      // 停止语音录制
      stopVoiceRecording();
      
      const current = players[currentPlayerIndex];
      const cardType = pendingCard ? pendingCard.type : 'share';
      const type = cardTypes[cardType];
      
      // 判断是否是心愿牌（自己使用的情况，pendingCard为null）
      const isWishFromSelf = !pendingCard && document.getElementById('modal-title').textContent === '心愿时刻';
      
      // 判断是否是万能牌变形后自己执行（分享牌或解释牌）
      const isWildSelfUse = !pendingCard && (
        document.getElementById('modal-title').textContent === '分享时刻' ||
        document.getElementById('modal-title').textContent === '解释时刻'
      );
      
      if (cardType === 'wish' || isWishFromSelf) {
        wishes.push({ player: current.name, wish: content });
        addRecord(current.name, '心愿牌', `许下心愿：${content}`);
        // 心愿牌使用后消耗掉，不再转赠给其他玩家
        alert('心愿已记录！您的心愿将在游戏结束时的总结中展示。');
      } else if (isWildSelfUse) {
        // 万能牌变形后自己执行
        const modalTitle = document.getElementById('modal-title').textContent;
        const cardName = modalTitle === '分享时刻' ? '分享牌' : '解释牌';
        addRecord(current.name, cardName, content);
      } else {
        addRecord(current.name, type.name, content);
      }
      
      document.getElementById('modal-answer').classList.remove('show');
      
      // 触发AI分析
      triggerAIAnalysis();
      
      // 如果是自己使用的心愿牌或万能牌变形，直接更新UI
      if (isWishFromSelf || isWildSelfUse) {
        // 检查游戏是否结束
        if (checkGameEnd()) return;
        updateGameUI();
      } else {
        clearPendingAndNext();
      }
    }
    
    function submitEvaluate() {
      const content = document.getElementById('evaluate-content').value.trim();
      if (!content) {
        alert('请输入评价内容');
        return;
      }
      
      // 停止语音录制
      stopVoiceRecording();
      
      const current = players[currentPlayerIndex];
      
      // 判断是否是自己使用评价牌（万能牌变形后）
      const isSelfUse = pendingCard && pendingCard.selfUse;
      
      if (isSelfUse) {
        const targetName = pendingCard.targetPlayer;
        addRecord(current.name, '评价牌', `对${targetName}说：${content}`);
        pendingCard = null;
      } else {
        const evaluateTarget = pendingCard ? pendingCard.fromPlayer : '某人';
        addRecord(current.name, '评价牌', `对${evaluateTarget}说：${content}`);
      }
      
      document.getElementById('modal-evaluate').classList.remove('show');
      
      // 触发AI分析
      triggerAIAnalysis();
      
      // 如果是自己使用，直接更新UI
      if (isSelfUse) {
        if (checkGameEnd()) return;
        updateGameUI();
      } else {
        clearPendingAndNext();
      }
    }
    
    function clearPendingAndNext() {
      pendingCard = null;
      updateGameUI();
    }
    
    function nextTurn() {
      checkWishCardTrigger();
      
      let nextIndex = currentPlayerIndex;
      let loopCount = 0;
      do {
        nextIndex = (nextIndex + playDirection + players.length) % players.length;
        loopCount++;
        if (loopCount > players.length) break;
      } while (!players[nextIndex].active);
      
      currentPlayerIndex = nextIndex;
      
      if (playDirection === 1 && currentPlayerIndex === 0) round++;
      if (playDirection === -1 && currentPlayerIndex === players.length - 1) round++;
      
      updateGameUI();
    }
    
    function checkWishCardTrigger() {
      // 心愿牌现在是自己使用后随机分给其他玩家，不再需要额外触发
      return;
    }
    
    // 检查游戏是否结束（任意玩家手牌打完）
    function checkGameEnd() {
      const emptyHandPlayer = players.find(p => p.active && p.cards.length === 0);
      if (emptyHandPlayer) {
        // 显示游戏结束提示
        setTimeout(() => {
          alert(`${emptyHandPlayer.name} 的手牌已全部打完，游戏结束！\n即将查看对话总结...`);
          goToSummary();
        }, 500);
        return true;
      }
      return false;
    }
    
    function addRecord(playerName, cardName, content) {
      records.push({ player: playerName, card: cardName, content: content, time: new Date() });
      updateRecords();
    }
    
    function updateRecords() {
      const container = document.getElementById('records-list');
      if (records.length === 0) {
        container.innerHTML = '<div class="empty-records">还没有对话记录，出牌开始吧！</div>';
        return;
      }
      
      container.innerHTML = records.slice(-5).map(r => `
        <div class="record-item">
          <div class="record-header">
            <span class="record-player">${r.player}</span>
            <span class="record-card">${r.card}</span>
          </div>
          <div class="record-content">${r.content}</div>
        </div>
      `).join('');
    }
    
    // ========== AI 分析系统 ==========
    async function callAPI(messages) {
      try {
        const response = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: MODEL,
            messages: messages,
            max_tokens: 1024,
            temperature: 1.0,
          })
        });
        
        if (!response.ok) {
          throw new Error(`API错误: ${response.status}`);
        }
        
        const data = await response.json();
        return data.choices[0].message.content;
      } catch (error) {
        console.error('API调用失败:', error);
        return null;
      }
    }
    
    async function triggerAIAnalysis() {
      if (analysisInProgress || records.length === 0) return;
      analysisInProgress = true;
      
      document.getElementById('ai-insight').innerHTML = '<div class="ai-loading"><div class="spinner"></div><span>AI 分析中...</span></div>';
      
      const recentRecords = records.slice(-10).map(r => `${r.player}(${r.card}): ${r.content}`).join('\n');
      const playerNames = players.map(p => p.name).join('、');
      
      const prompt = `你是一个专业的家庭对话分析师。请分析以下家庭对话记录，并完成两个任务：

对话参与者：${playerNames}

最近的对话记录：
${recentRecords}

任务1：为每位参与者分析当前的心理状态，用一个词概括（如：开心、感动、思考、紧张、放松、期待、感恩、犹豫等）。

任务2：给出一段简短的对话洞察（2-3句话），以一种幽默、轻松的方式，说明当前对话的氛围和值得关注的点。

请严格按以下JSON格式回复（不要有其他内容）：
{
  "emotions": {
    "玩家名1": {"emoji": "表情符号", "word": "一个词"},
    "玩家名2": {"emoji": "表情符号", "word": "一个词"}
  },
  "insight": "对话洞察内容"
}

表情符号参考：开心用&#128522;，感动用&#129402;，思考用&#129300;，紧张用&#128556;，放松用&#128524;，期待用&#129321;，感恩用&#128591;，犹豫用&#128533;`;
      
      const messages = [
        { role: "system", content: "你是一个专业的家庭对话分析师，擅长分析家庭成员之间的对话，理解每个人的情绪和心理状态。请始终用JSON格式回复。" },
        { role: "user", content: prompt }
      ];
      
      const result = await callAPI(messages);
      
      if (result) {
        try {
          // 尝试解析JSON
          const jsonMatch = result.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const analysis = JSON.parse(jsonMatch[0]);
            
            // 更新玩家情绪
            if (analysis.emotions) {
              Object.keys(analysis.emotions).forEach(name => {
                if (playerEmotions[name]) {
                  playerEmotions[name] = analysis.emotions[name];
                }
              });
              updatePlayerEmotionsDisplay();
              updatePlayersBar();
            }
            
            // 更新洞察
            if (analysis.insight) {
              document.getElementById('ai-insight').textContent = analysis.insight;
            }
            
            lastAIAnalysis = analysis;
          }
        } catch (e) {
          console.error('解析AI响应失败:', e);
          document.getElementById('ai-insight').textContent = '对话分析中，请继续游戏...';
        }
      } else {
        document.getElementById('ai-insight').textContent = '对话进行中，AI正在观察...';
      }
      
      analysisInProgress = false;
    }
    
    function updatePlayerEmotionsDisplay() {
      const container = document.getElementById('player-emotions');
      container.innerHTML = players.map(p => {
        const emotion = playerEmotions[p.name] || { emoji: '&#128566;', word: '等待' };
        return `
          <div class="player-emotion-card">
            <div class="player-emotion-name">${p.name}</div>
            <div class="player-emotion-emoji">${emotion.emoji}</div>
            <div class="player-emotion-word">${emotion.word}</div>
          </div>
        `;
      }).join('');
    }
    
    // ========== AI 总结生成 ==========
    async function generateAISummary() {
      const container = document.getElementById('summary-content');
      container.innerHTML = '<div class="ai-loading"><div class="spinner"></div><span>AI 正在生成总结...</span></div>';
      
      if (records.length === 0) {
        container.innerHTML = '<p style="text-align:center;color:#666;">还没有对话记录，先玩几轮吧！</p>';
        return;
      }
      
      const allRecords = records.map(r => `${r.player}(${r.card}): ${r.content}`).join('\n');
      const playerNames = players.map(p => p.name).join('、');
      const wishList = wishes.map(w => `${w.player}的心愿：${w.wish}`).join('\n') || '暂无心愿';
      
      const prompt = `你是一个专业的家庭对话分析师和心理咨询师。请为这次深度对话游戏生成一份温暖、有洞察力的总结报告。

对话参与者：${playerNames}
对话轮次：${round}轮
心愿池：
${wishList}

完整对话记录：
${allRecords}

请生成一份包含以下四段内容的总结报告，不要出现‘**’之间的标题内容：

**对话概览**简要描述这次对话的整体情况（2-3句话）

**每位参与者分析**
   - 分析每位参与者在对话中展现的特点
   - 他们表达的核心情感和想法
   - 给每个人一句温暖的评价

**家庭关系洞察**
   - 从对话中发现的家庭关系特点
   - 值得珍惜的互动瞬间
   - 可能需要更多关注的方面

**鼓励与建议**
   - 给这个家庭的真诚鼓励
   - 后续可以尝试的沟通建议

请用温暖、真诚、有洞察力的语气来写，让参与者感受到被理解和支持。`;
      
      const messages = [
        { role: "system", content: "你是一个专业的家庭对话分析师和心理咨询师，你的任务是为家庭对话生成温暖、有洞察力的总结报告。你的语言风格温暖真诚，善于发现每个人的闪光点，给予肯定和鼓励。" },
        { role: "user", content: prompt }
      ];
      
      const result = await callAPI(messages);
      
      // 生成心愿池HTML（放在总结上方）
      const wishPoolHtml = wishes.length > 0 
        ? `<div class="wish-pool-card">
            <div class="wish-pool-title">&#127775; 心愿池</div>
            <div class="wish-pool-list">
              ${wishes.map(w => `<div class="wish-item">&#127775; ${w.player}的心愿：${w.wish}</div>`).join('')}
            </div>
          </div>`
        : '';
      
      if (result) {
        container.innerHTML = `
          ${wishPoolHtml}
          
          <div class="summary-card">
            <div class="summary-title">对话总结</div>
            <div class="summary-section">
              <div class="ai-summary-text">${result.replace(/\n/g, '<br>')}</div>
            </div>
          </div>
          
          <div class="encouragement-card">
            <div class="encouragement-title">&#127775; 本次对话数据</div>
            <div class="encouragement-text">
              参与人数：${players.length} 人<br>
              对话轮次：${round} 轮<br>
              发言记录：${records.length} 条<br>
              收集心愿：${wishes.length} 个
            </div>
          </div>
        `;
      } else {
        // 生成本地总结
        container.innerHTML = generateLocalSummary();
      }
    }
    
    function generateLocalSummary() {
      const emotionSummary = players.map(p => {
        const emotion = playerEmotions[p.name] || { emoji: '&#128566;', word: '等待' };
        return `<div>${p.avatar} ${p.name}：${emotion.emoji} ${emotion.word}</div>`;
      }).join('');
      
      // 心愿池放在最上方
      const wishPoolHtml = wishes.length > 0 
        ? `<div class="wish-pool-card">
            <div class="wish-pool-title">&#127775; 心愿池</div>
            <div class="wish-pool-list">
              ${wishes.map(w => `<div class="wish-item">&#127775; ${w.player}的心愿：${w.wish}</div>`).join('')}
            </div>
          </div>`
        : '';
      
      return `
        ${wishPoolHtml}
        
        <div class="summary-card">
          <div class="summary-title">&#128202; 本次对话总结</div>
          
          <div class="summary-section">
            <div class="summary-section-title">&#127919; 对话概览</div>
            <div class="summary-list">
              本次对话共进行了 ${round} 轮，${players.length} 位家庭成员参与了 ${records.length} 次分享。
            </div>
          </div>
          
          <div class="summary-section">
            <div class="summary-section-title">&#128173; 参与者状态</div>
            <div class="summary-list">${emotionSummary}</div>
          </div>
        </div>
        
        <div class="encouragement-card">
          <div class="encouragement-title">&#127775; 继续前进</div>
          <div class="encouragement-text">
            感谢你们愿意坐下来，用这种方式进行深度对话。<br><br>
            每一次真诚的分享，都是家庭关系更进一步的契机。<br><br>
            希望今天的对话能够成为你们美好回忆的一部分！
          </div>
        </div>
      `;
    }
    
    function restartGame() {
      players = [];
      records = [];
      wishes = [];
      confirmedPlayers = [];
      playerEmotions = {};
      round = 1;
      currentPlayerIndex = 0;
      showPage('setup');
      initPlayerInputs();
    }
    
    // ========== 语音识别功能 ==========
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let voiceRecognition = null;
    let isVoiceRecording = false;
    let currentVoiceTarget = null; // 'answer' 或 'evaluate'
    
    // 初始化语音识别
    function initVoiceRecognition() {
      if (!SpeechRecognition) {
        console.log('浏览器不支持语音识别');
        // 隐藏语音按钮
        document.querySelectorAll('.voice-btn').forEach(btn => {
          btn.style.display = 'none';
        });
        return;
      }
      
      voiceRecognition = new SpeechRecognition();
      voiceRecognition.continuous = true;
      voiceRecognition.interimResults = true;
      voiceRecognition.lang = 'zh-CN';
      
      voiceRecognition.onstart = function() {
        isVoiceRecording = true;
        updateVoiceUI(true);
      };
      
      voiceRecognition.onend = function() {
        if (isVoiceRecording) {
          // 如果还在录音状态，自动重新开始
          try {
            voiceRecognition.start();
          } catch (e) {
            stopVoiceRecording();
          }
        } else {
          updateVoiceUI(false);
        }
      };
      
      voiceRecognition.onresult = function(event) {
        let interimTranscript = '';
        let finalTranscript = '';
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }
        
        // 获取目标输入框
        const targetInput = currentVoiceTarget === 'answer' 
          ? document.getElementById('modal-input')
          : document.getElementById('evaluate-content');
        
        if (targetInput) {
          // 追加最终识别的文字
          if (finalTranscript) {
            targetInput.value += finalTranscript;
          }
          
          // 显示临时识别状态
          const statusEl = document.getElementById('voice-status-' + currentVoiceTarget);
          if (statusEl && interimTranscript) {
            statusEl.textContent = '识别中: ' + interimTranscript;
            statusEl.classList.add('recording');
          }
        }
      };
      
      voiceRecognition.onerror = function(event) {
        console.error('语音识别错误:', event.error);
        
        const statusEl = currentVoiceTarget 
          ? document.getElementById('voice-status-' + currentVoiceTarget)
          : null;
        
        switch(event.error) {
          case 'no-speech':
            // 静默处理
            break;
          case 'audio-capture':
            if (statusEl) statusEl.textContent = '未检测到麦克风';
            stopVoiceRecording();
            break;
          case 'not-allowed':
            if (statusEl) statusEl.textContent = '请允许使用麦克风';
            stopVoiceRecording();
            break;
          default:
            if (statusEl) statusEl.textContent = '识别出错，请重试';
            stopVoiceRecording();
        }
      };
    }
    
    // 切换语音输入
    function toggleVoiceInput(target) {
      if (!SpeechRecognition) {
        alert('您的浏览器不支持语音识别，请使用 Chrome、Edge 或 Safari 浏览器。');
        return;
      }
      
      if (isVoiceRecording && currentVoiceTarget === target) {
        stopVoiceRecording();
      } else {
        // 如果正在录其他的，先停止
        if (isVoiceRecording) {
          stopVoiceRecording();
        }
        startVoiceRecording(target);
      }
    }
    
    // 开始语音录制
    function startVoiceRecording(target) {
      if (!voiceRecognition) {
        initVoiceRecognition();
      }
      
      currentVoiceTarget = target;
      
      const statusEl = document.getElementById('voice-status-' + target);
      if (statusEl) {
        statusEl.textContent = '正在聆听...';
        statusEl.classList.add('recording');
      }
      
      try {
        voiceRecognition.start();
      } catch (e) {
        console.error('启动语音识别失败:', e);
      }
    }
    
    // 停止语音录制
    function stopVoiceRecording() {
      isVoiceRecording = false;
      currentVoiceTarget = null;
      
      if (voiceRecognition) {
        try {
          voiceRecognition.stop();
        } catch (e) {
          console.error('停止语音识别失败:', e);
        }
      }
      
      updateVoiceUI(false);
    }
    
    // 更新语音UI状态
    function updateVoiceUI(recording) {
      ['answer', 'evaluate'].forEach(target => {
        const btn = document.getElementById('voice-btn-' + target);
        const status = document.getElementById('voice-status-' + target);
        
        if (recording && currentVoiceTarget === target) {
          if (btn) btn.classList.add('recording');
          if (status) {
            status.textContent = '正在聆听...';
            status.classList.add('recording');
          }
        } else {
          if (btn) btn.classList.remove('recording');
          if (status) {
            status.textContent = '';
            status.classList.remove('recording');
          }
        }
      });
    }
    
    // ========== 初始化 ==========
    document.addEventListener('DOMContentLoaded', function() {
      initPlayerInputs();
      updatePlayerEmotionsDisplay();
      initVoiceRecognition();
    });
  </script>
</body>
</html>
